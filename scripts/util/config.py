#!/usr/bin/env python

import sys
import os
import argparse
import textwrap

import commentjson


def get_input_paths(config_file="config/config.js", verbose=True):
  '''
  '''
  with open(config_file) as config_fh:
    config = commentjson.load(config_fh)

  #Should this also handle parameter_dir and output_spec file location?
  #At least for now, no. The matching 'set_input_paths' method should likely
  # only apply to this set of files.
  input_filenames = ['hist_climate_file', 'proj_climate_file',
                     'veg_class_file', 'drainage_file', 'soil_texture_file',
                     'co2_file', 'proj_co2_file', 'runmask_file', 'topo_file',
                     'fri_fire_file', 'hist_exp_fire_file',
                     'proj_exp_fire_file']
  if verbose:
    print("Fetching input paths for filenames:", *input_filenames, sep=', ')

  paths = []
  for filename in input_filenames:
#    path = os.path.dirname(config['IO'][filename])
    path = config['IO'][filename]
    if path not in paths:
      paths.append(path)

  return paths


def cmdline_define():
  '''Define the command line interface and return the parser object.'''

  parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=textwrap.dedent('''
      Helper script for a dvm-dos-tem config file.
    ''')
  )
  parser.add_argument('file', nargs='?', metavar=('FILE'),
      help=textwrap.dedent('''The config file to operate on.'''))

  parser.add_argument('--verbose', action='store_true',
      help=textwrap.dedent('''Print info to stdout when script runs.'''))

  parser.add_argument('--get-input-paths', action='store_true',
      help=textwrap.dedent('''Returns all input file paths'''))

  return parser

def cmdline_parse(argv=None):
  '''
  The command line interface specification and parser for util config.py.

  If parse_args(...) is called with argv=None, then parse_args(...) will
  use sys.argv[1:]. Otherwise argv is parsed according to the specification.

  Parameters
  ----------
  argv : None or list of strings
    arguments that argparse library will parse; if None, then sys.argv[1:] are
    parsed.

  Returns
  -------
  args : Namespace generated by argparse

  '''
  parser = cmdline_define()

  args = parser.parse_args(argv)

  # print(argv)
  # print(args)

  # Force vebosity on if user requests showing data
  #if args.show:
    #args.verbose = True # ?? Not sure about this...
  
  if (args.file is None) or (not os.path.isfile(args.file)):
    parser.error("'{}' is an invalid path to a config file!".format(args.file))

  return args


def cmdline_run(args):
  '''
  Executes based on the command line arguments.

  Parameters
  ----------
  args : Namespace
    Should be a Namespace with all the appropriate arguments.

  Returns
  -------
  exit_code : int 
    Non-zero if the program cannot complete successfully.

  '''
  if args.get_input_paths:
    get_input_paths(args.file, args.verbose)

  return 0


def cmdline_entry(argv=None):
  '''
  Wrapper allowing for easier testing of the cmdline run and parse functions.
  '''
  args = cmdline_parse(argv)
  return cmdline_run(args)


if __name__ == '__main__':
  sys.exit(cmdline_entry()) # this makes sure appropriate exit code is passed on.

